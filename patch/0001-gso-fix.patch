diff --git a/src/vnet/devices/af_packet/node.c b/src/vnet/devices/af_packet/node.c
index e2f87b10b..c9cc50577 100644
--- a/src/vnet/devices/af_packet/node.c
+++ b/src/vnet/devices/af_packet/node.c
@@ -209,6 +209,7 @@ af_packet_device_input_fn (vlib_main_t * vm, vlib_node_runtime_t * node,
   u32 thread_index = vm->thread_index;
   u32 n_buffer_bytes = vlib_buffer_get_default_data_size (vm);
   u32 min_bufs = apif->rx_req->tp_frame_size / n_buffer_bytes;
+  u32 eth_header_size = sizeof (ethernet_header_t);
 
   n_free_bufs = vec_len (apm->rx_buffers[thread_index]);
   if (PREDICT_FALSE (n_free_bufs < VLIB_FRAME_SIZE))
@@ -292,7 +293,10 @@ af_packet_device_input_fn (vlib_main_t * vm, vlib_node_runtime_t * node,
 		  first_b0 = vlib_get_buffer (vm, first_bi0);
 		  if (tph->tp_status & TP_STATUS_CSUMNOTREADY)
 		    mark_tcp_udp_cksum_calc (first_b0, &l4_hdr_sz);
-		  if (tph->tp_snaplen > apif->host_mtu)
+		  /* This is a trade-off for GSO. As kernel isn't passing
+		   * us the GSO state or size, we guess it by comparing it
+		   * to the host MTU of the interface */
+		  if (tph->tp_snaplen > (apif->host_mtu + eth_header_size))
 		    fill_gso_buffer_flags (first_b0, apif->host_mtu,
 					   l4_hdr_sz);
 		}
